[
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting started",
    "section": "",
    "text": "To start building R packages using extendr you will need to have R and Rust toolchain installed on your machine.",
    "crumbs": [
      "extendR: User guide",
      "Getting started"
    ]
  },
  {
    "objectID": "getting-started.html#r",
    "href": "getting-started.html#r",
    "title": "Getting started",
    "section": "R",
    "text": "R\nEnsure that you have a relatively new version of R installed. It is recommended to use a moderately new version (&gt;= 4.2.0).\n\n\n\n\n\n\nNote\n\n\n\nInstall the newest version of R from CRAN\n\n\nThe R package {rextendr} is used to simplify the scaffolding of extendr projects as well as document Rust functions and objects. Install the development version of {rextendr} to have the most up to date changes.\n# install pak if not available\nif (!requireNamespace(\"pak\")) install.packages(\"pak\")\n\n# install development version of rextendr\npak::pak(\"extendr/rextendr\")",
    "crumbs": [
      "extendR: User guide",
      "Getting started"
    ]
  },
  {
    "objectID": "getting-started.html#rust",
    "href": "getting-started.html#rust",
    "title": "Getting started",
    "section": "Rust",
    "text": "Rust\nNext, ensure that you have Rust installed. extendr has a minimum supported Rust version (msrv) of 1.64. Follow the rustup installation instructions to install Rust.\n\n\n\n\n\n\nTip\n\n\n\nIf you are using Windows, you will also need to install the stable-x86_64-pc-windows-msvc toolchain. From your terminal run the following\nrustup toolchain install stable-x86_64-pc-windows-msvc\nrustup default stable-x86_64-pc-windows-msvc\n\n\nOnce you have installed the Rust toolchain, ensure it is compatible with extendr.\nFrom R run:\n\nrextendr::rust_sitrep()\n\nRust infrastructure sitrep:\n✔ \"rustup\": 1.26.0 (5af9b9484 2023-04-05)\n✔ \"cargo\": 1.79.0-nightly (499a61ce7 2024-03-26)\nℹ host: aarch64-apple-darwin\nℹ toolchains: stable-aarch64-apple-darwin, nightly-aarch64-apple-darwin\n  (default), and 1.64.0-aarch64-apple-darwin\nℹ targets: aarch64-apple-darwin and wasm32-unknown-unknown\n\n\nIf there are no issues reported by the situation report (sitrep), you are ready to start building Rust-powered R packages!",
    "crumbs": [
      "extendR: User guide",
      "Getting started"
    ]
  },
  {
    "objectID": "getting-started.html#post-script-tools-for-writing-rust",
    "href": "getting-started.html#post-script-tools-for-writing-rust",
    "title": "Getting started",
    "section": "Post Script: Tools for Writing Rust",
    "text": "Post Script: Tools for Writing Rust\nIf you are new to writing Rust, this following section contains some tips.\nFirst, it is recommended to install a configurable code editor like Visual Studio Code (VS Code).\nOnce you have VS Code, or another text editor, installed you will need the rust-analyzer. The rust-analyzer will provide type hinting and auto-completion suggestions. It is very helpful!",
    "crumbs": [
      "extendR: User guide",
      "Getting started"
    ]
  },
  {
    "objectID": "project-structure.html",
    "href": "project-structure.html",
    "title": "extendr project structure",
    "section": "",
    "text": "A extendr-powered R package has a fairly unique structure. This section briefly outlines the structure of an extendr package and the important files.\nextendr works by creating a Rust library crate in src/rust that is defined by src/rust/Cargo.toml.\nNote the crate-type = [ 'staticlib' ]. When this library is compiled, it creates a static library which can then be called from R.",
    "crumbs": [
      "extendR: User guide",
      "extendr project structure"
    ]
  },
  {
    "objectID": "project-structure.html#controlling-exports-to-r-lib.rs",
    "href": "project-structure.html#controlling-exports-to-r-lib.rs",
    "title": "extendr project structure",
    "section": "Controlling exports to R: lib.rs",
    "text": "Controlling exports to R: lib.rs\nThe lib.rs file determines what will be exposed to your R package. The extendr_module! macro in lib.rs controls what will have wrappers provided to your R package.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nThe mod hellorust is the name of the R package. Additional functions, impls, and modules can also be added to this macro.",
    "crumbs": [
      "extendR: User guide",
      "extendr project structure"
    ]
  },
  {
    "objectID": "project-structure.html#building-the-package-makevars",
    "href": "project-structure.html#building-the-package-makevars",
    "title": "extendr project structure",
    "section": "Building the package: Makevars",
    "text": "Building the package: Makevars\nWhen creating an R package that uses compiled code, a file called Makevars is used.\n\n\n\n\n\n\nNote\n\n\n\nSee Using Makevars in Writing R Extensions for a thorough discussion.\n\n\nMakevars is used as a preprocessing step for compiling an R package. The files Makevars and Makevars.win compile the Rust library in src/rust, and link to the library.\n\n\n\n\n\n\nTip\n\n\n\nMakevars is used for *nix operating systems and Makevars.win is used for Windows.",
    "crumbs": [
      "extendR: User guide",
      "extendr project structure"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "extendR: User guide",
    "section": "",
    "text": "The extendr suite of software packages provides a set of utilities for bridging the R and Rust programming languages, making it easier for users to pass data between them using automatically generated bindings. In so doing, it overcomes a fundamental challenge of all such language bindings, namely, the fact that the two languages make different design choices regarding the representation of data types. Most of the time, data types in Rust and R map quite nicely. In other cases, it takes careful consideration. And, in a few unfortunate cases, it is not even possible. Generally speaking, though, if an R version of a Rust type exists, extendr will do that mapping for you, but you will on occasion have to do some of that work yourself.\nTo help guide you toward best practices here, we have put together this website as a user guide, with lots of examples showcasing all things extendr, Rust, and R, as well as the confluence of all three.\nSee https://extendr.github.io/ for more information.\n\n\nIf you have any questions or are looking for advice, feel free to join the community’s Discord server. You can usually find the maintainers there, as well as other helpful extendr users."
  },
  {
    "objectID": "index.html#community-support",
    "href": "index.html#community-support",
    "title": "extendR: User guide",
    "section": "",
    "text": "If you have any questions or are looking for advice, feel free to join the community’s Discord server. You can usually find the maintainers there, as well as other helpful extendr users."
  },
  {
    "objectID": "extendr-macro.html",
    "href": "extendr-macro.html",
    "title": "Making Rust items available to R",
    "section": "",
    "text": "The power of extendr is in its ability to use Rust from R. The #[extendr] macro is what determines what is exported to R from Rust. This section covers the basic usage of the #[extendr] macro.\n#[extendr] is what is referred to as an attribute macro (which itself is a type of procedural macro). An attribute macro is attached to an item such as a function, struct, enum, or impl.\nThe #[extendr] attribute macro indicates that an item should be made available to R. However, it can only be used with a function or an impl block.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "extendr-macro.html#exporting-functions",
    "href": "extendr-macro.html#exporting-functions",
    "title": "Making Rust items available to R",
    "section": "Exporting functions",
    "text": "Exporting functions\nIn order to make a function available to R, two things must happen. First, the #[extendr] macro must be attached to the function. For example, you can create a function answer_to_life()\n\n\n\n\n\n\nNote\n\n\n\n\n\nIn the Hitchhiker’s Guide to the Galaxy, the number 42 is the answer to the universe. See this fun article from Scientific American\n\n\n\n#[extendr]\nfn answer_to_life() -&gt; i32 {\n    42\n}\nBy adding the #[extendr] attribute macro to the answer_to_life() function, we are indicating that this function has to be compatible with R. This alone, however, does not make the function available to R. It must be made available via the extendr_module! {} macro in lib.rs.\nextendr_module! {\n    mod hellorust;\n    fn answer_to_life;\n}\n\n\n\n\n\n\nTip\n\n\n\nEverything that is made available in the extendr_module! {} macro in lib.rs must be compatible with R as indicated by the #[extendr] macro. Note that the module name mod hellorust must be the name of the R package that this is part of. If you have created your package with rextendr::use_extendr() this should be set automatically. See Hello, world!.\n\n\nWhat happens if you try and return something that cannot be represented by R? Take this example, an enum Shape is defined and a function takes a string &str. Based on the value of the arugment, an enum variant is returned.\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nWhen this is compiled, an error occurs because extendr does not know how to convert the Shape enum into something that R can use. The error is fairly informative!\n#[extendr]\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\n   = help: the following other types implement trait `ToVectorValue`:\n             bool\n             i8\n             i16\n             i32\n             i64\n             usize\n             u8\n             u16\n           and 45 others\n   = note: required for `extendr_api::Robj` to implement `From&lt;Shape&gt;`\n   = note: this error originates in the attribute macro `extendr` \nIt tells you that Shape does not implement the ToVectorValue trait. The ToVectorValue trait is what enables items from Rust to be returned to R.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "extendr-macro.html#tovectorvalue-trait",
    "href": "extendr-macro.html#tovectorvalue-trait",
    "title": "Making Rust items available to R",
    "section": "ToVectorValue trait",
    "text": "ToVectorValue trait\nIn order for an item to be returned from a function marked with the #[extendr] attribute macro, it must be able to be turned into an R object. In extendr, the struct Robj is a catch all for any type of R object.\n\n\n\n\n\n\nNote\n\n\n\nFor those familiar with PyO3, the Robj struct is similar in concept to the PyAny struct.\n\n\nThe ToVectorValue trait is what is used to convert Rust items into R objects. The trait is implemented on a number of standard Rust types such as i32, f64, usize, String and more (see all foreign implementations here) which enables these functions to be returned from a Rust function marked with #[extendr].\n\n\n\n\n\n\nNote\n\n\n\nIn essence, all items that are returned from a function must be able to be turned into an Robj. Other extendr types such as List, for example, have a From&lt;T&gt; for Robj implementation that defines how it is converted into an Robj.\n\n\nThis means that with a little extra work, the Shape enum can be returned to R. To do so, the #[extendr] macro needs to be added to an impl block.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "extendr-macro.html#exporting-impl-blocks",
    "href": "extendr-macro.html#exporting-impl-blocks",
    "title": "Making Rust items available to R",
    "section": "Exporting impl blocks",
    "text": "Exporting impl blocks\nThe other supported item that can be made available to R is an impl block. impl is a keyword that allows you to implement a trait or an inherent implementation. The #[extendr] macro works with inherent implementations. These are impls on a type such as an enum or a struct. extendr does not support using #[extendr] on trait impls.\n\n\n\n\n\n\nNote\n\n\n\nYou can only add an inherent implementation on a type that you have own and not provided by a third party crate. This would violate the orphan rules.\n\n\nContinuing with the Shape example, this enum alone cannot be returned to R. For example, the following code will result in a compilation error\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nerror[E0277]: the trait bound `Shape: ToVectorValue` is not satisfied\n  --&gt; src/lib.rs:19:1\n   |\n19 | #[extendr]\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\nHowever, if an impl block is added to the Shape enum, it can be returned to R.\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nimpl Shape {\n    fn new(x: &str) -&gt; Self {\n        match x {\n            \"triangle\" =&gt; Self::Triangle,\n            \"rectangle\" =&gt; Self::Rectangle,\n            \"pentagon\" =&gt; Self::Pentagon,\n            \"hexagon\" =&gt; Self::Hexagon,\n            &_ =&gt; unimplemented!(),\n        }\n    }\n\n    fn n_coords(&self) -&gt; usize {\n        match &self {\n            Shape::Triangle =&gt; 3,\n            Shape::Rectangle =&gt; 4,\n            Shape::Pentagon =&gt; 4,\n            Shape::Hexagon =&gt; 5,\n        }\n    }\n}\n\nIn this example two new methods are added to the Shape enum. The first new() is like the make_shape() function that was shown earlier: it takes a &str and returns an enum variant. Now that the enum has an impl block with #[extendr] attribute macro, it can be exported to R by inclusion in the extendr_module! {} macro.\nextendr_module! {\n    mod hellorust;\n    impl Shape;\n}\nDoing so creates an environment in your package called Shape. The environment contains all of the methods that are available to you.\n\n\n\n\n\n\nTip\n\n\n\nThere are use cases where you may not want to expose any methods but do want to make it possible to return a struct or an enum to the R. You can do this by adding an empty impl block with the #[extendr] attribute macro.\n\n\nIf you run as.list(Shape) you will see that there are two functions in the environment which enable you to call the methods defined in the impl block. You might think that this feel like an R6 object and you’d be right because an R6 object essentially is an environment!\n\nas.list(Shape)\n\n$n_coords\nfunction () \n.Call(\"wrap__Shape__n_coords\", self, PACKAGE = \"librextendr1.dylib\")\n\n$new\nfunction (x) \n.Call(\"wrap__Shape__new\", x, PACKAGE = \"librextendr1.dylib\")\n\n\nCalling the new() method instantiates a new enum variant.\n\ntri &lt;- Shape$new(\"triangle\")\ntri\n\n&lt;pointer: 0x13373d320&gt;\nattr(,\"class\")\n[1] \"Shape\"\n\n\nThe newly made tri object is an external pointer to the Shape enum in Rust. This pointer has the same methods as the Shape environment—though they cannot be seen in the same way. For example you can run the n_coords() method on the newly created object.\n\ntri$n_coords()\n\n[1] 3\n\n\n\n\n\n\n\n\nTip\n\n\n\nTo make the methods visible to the Shape class you can define a .DollarNames method which will allow you to preview the methods and attributes when using the $ syntax. This is very handy to define when making an impl a core part of your package.\n\n.DollarNames.Shape = function(env, pattern = \"\") {\n  ls(Shape, pattern = pattern)\n}\n\n\n\n\nimpl ownership\nAdding the #[extendr] macro to an impl allows the struct or enum to be made available to R as an external pointer. Once you create an external pointer, that is then owned by R. So you can only get references to it or mutable references. If you need an owned version of the type, then you will need to clone it.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "extendr-macro.html#accessing-exported-impls-from-rust",
    "href": "extendr-macro.html#accessing-exported-impls-from-rust",
    "title": "Making Rust items available to R",
    "section": "Accessing exported impls from Rust",
    "text": "Accessing exported impls from Rust\nInvariably, if you have made an impl available to R via the #[extendr] macro, you may want to define functions that take the impl as a function argument.\nDue to R owning the impl’s external pointer, these functions cannot take an owned version of the impl as an input. For example trying to define a function that subtracts an integer from the n_coords() output like below returns a compiler error.\n#[extendr]\nfn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n    (x.n_coords() as i32) - n\n}\nthe trait bound `Shape: extendr_api::FromRobj&lt;'_&gt;` is not satisfied\n  --&gt; src/lib.rs:53:22\n   |\n   | fn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n   |                      ^^^^^ the trait `extendr_api::FromRobj&lt;'_&gt;` is not implemented for `Shape`\n   |\nhelp: consider borrowing here\n   |\n   | fn subtract_coord(x: &Shape, n: i32) -&gt; i32 {\n   |                      +\n   | fn subtract_coord(x: &mut Shape, n: i32) -&gt; i32 {\n   |                      ++++\nAs most often, the compiler’s suggestion is a good one. Use &Shape to use a reference.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "href": "extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "title": "Making Rust items available to R",
    "section": "ExternalPtr: returning arbitrary Rust types",
    "text": "ExternalPtr: returning arbitrary Rust types\nIn the event that you need to return a Rust type to R that doesn’t have a compatible impl or is a type that you don’t own, you can use ExternalPtr&lt;T&gt;. The ExternalPtr struct allows any item to be captured as a pointer and returned to R.\nHere, for example, an ExternalPtr&lt;Shape&gt; is returned from the shape_ptr() function.\n\n\n\n\n\n\nTip\n\n\n\nAnything that is wrapped in ExternalPtr&lt;T&gt; must implement the Debug trait.\n\n\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn shape_ptr(shape: &str) -&gt; ExternalPtr&lt;Shape&gt; {\n    let variant = match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!(),\n    };\n\n    ExternalPtr::new(variant)\n}\n\nUsing an external pointer, however, is far more limiting than the impl block. For example, you cannot access and of its methods.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\ntri_ptr$n_coords()\n\nError in tri_ptr$n_coords: object of type 'externalptr' is not subsettable\n\n\nTo use an ExternalPtr&lt;T&gt;, you have to go through a bit of extra work for it.\n#[extendr]\nfn n_coords_ptr(x: Robj) -&gt; i32 {\n    let shape = TryInto::&lt;ExternalPtr&lt;Shape&gt;&gt;::try_into(x); \n    \n    match shape {\n        Ok(shp) =&gt; shp.n_coords() as i32,\n        Err(_) =&gt; 0\n    }\n}\nThis function definition takes an Robj and from it, tries to create an ExternalPtr&lt;Shape&gt;. Then, if the conversion did not error, it returns the number of coordinates as an i32 (R’s version of an integer) and if there was an error converting, it returns 0.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\n\nn_coords_ptr(tri_ptr)\n\n[1] 3\n\nn_coords_ptr(list())\n\n[1] 0\n\n\nFor a good example of using ExternalPtr&lt;T&gt; within an R package, refer to the b64 R package.",
    "crumbs": [
      "extendR: User guide",
      "Making Rust items available to R"
    ]
  },
  {
    "objectID": "hello-world.html",
    "href": "hello-world.html",
    "title": "Hello, world!",
    "section": "",
    "text": "Once you have Rust and {rextendr} installed, you can begin creating Rust-powered R packages.\nThe first step to using extendr is to create an R package. It is recommend to create a new package using the package {usethis}.\nusethis::create_package(\"hellorust\")\nIf you are in the RStudio IDE, a new R project will be opened up for you with the file structure of a new R package.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n└── hellorust.Rproj\nNow that you have a new R package, you can add extendr to it.\nrextendr::use_extendr()\nThis will add an extendr package template to the R packge. We will go through the package structure in more depth shortly.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   └── extendr-wrappers.R\n├── hellorust.Rproj\n└── src\n    ├── Makevars\n    ├── Makevars.ucrt\n    ├── Makevars.win\n    ├── entrypoint.c\n    ├── hellorust-win.def\n    └── rust\n        ├── Cargo.toml\n        └── src\n            └── lib.rs\nInside of the file src/rust/src/lib.rs is a hello world function.\n/// Return string `\"Hello world!\"` to R.\n/// @export\n#[extendr]\nfn hello_world() -&gt; &'static str {\n    \"Hello world!\"\n}\n\n\n\n\n\n\nTip\n\n\n\nNote that roxygen2 can be used with Rust documentation comments /// instead of //.\n\n\nThe function is made available to R via the macro extendr_module!.\n// Macro to generate exports.\n// This ensures exported functions are registered with R.\n// See corresponding C code in `entrypoint.c`.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nUse the function rextendr::document() to automatically create R function wrappers to call the Rust function. This will recompile the Rust library.\nrextendr::document()\n#&gt;  rextendr::document()\n#&gt; ✔ Saving changes in the open files.\n#&gt; ℹ Generating extendr wrapper functions for package: hellorust.\n#&gt; ℹ Re-compiling hellorust (debug build)\n#&gt; .... truncated ....\n#&gt; ─  DONE (hellorust)\n#&gt; ✔ Writing 'R/extendr-wrappers.R'\n#&gt; ℹ Updating hellorust documentation\n#&gt; Writing NAMESPACE\n#&gt; ℹ Loading hellorust\n#&gt; Writing NAMESPACE\n#&gt; Writing hellorust-package.Rd\n#&gt; Writing hello_world.Rd\nThe file R/extendr-wrappers.R was updated and now contains\n#' Return string `\"Hello world!\"` to R.\n#' @export\nhello_world &lt;- function() .Call(wrap__hello_world)\nRun devtools::load_all() to make the function available to your session.\ndevtools::load_all()\n#&gt; ℹ Loading hellorust\nThe package hellorust has been loaded and now you can run hello_world()\nhello_world()\n#&gt; \"Hello world!\"",
    "crumbs": [
      "extendR: User guide",
      "Hello, world!"
    ]
  },
  {
    "objectID": "data-types.html",
    "href": "data-types.html",
    "title": "R to Rust type mapping",
    "section": "",
    "text": "extendr is allows us to create a bridge between R and Rust. When writing a function in Rust that is intended to be called from R, it is important that the input types be R types. There are many types of objects in R (almost) all of which are available in extendr via a wrapper struct.\nThe below lists the extendr structs that wrap R object types. These types can be used as function arguments or return values.",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "data-types.html#scalar-types",
    "href": "data-types.html#scalar-types",
    "title": "R to Rust type mapping",
    "section": "Scalar types",
    "text": "Scalar types\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger(1)\nRint\ni32\n\n\ndouble(1)\nRfloat\nf64\n\n\nlogical(1)\nRbool\nbool\n\n\ncomplex(1)\nRcplx\nComplex&lt;f64&gt;\n\n\ncharacter(1)\nRstr\nString",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "data-types.html#vector-types",
    "href": "data-types.html#vector-types",
    "title": "R to Rust type mapping",
    "section": "Vector types",
    "text": "Vector types\n\n\n\nR type\nextendr type\nextendr scalar type\nC API Type\n\n\n\n\ninteger()\nIntegers\nRint\nINTSXP\n\n\ndouble()\nDoubles\nRfloat\nREALSXP\n\n\nlogical()\nLogicals\nRbool\nLGLSXP\n\n\ncomplex()\nComplexes\nRcplx\nCPLXSXP\n\n\ncharacter()\nStrings\nRstr\nSTRSXP\n\n\nraw()\nRaw\n&[u8]\nRAWSXP\n\n\nlist()\nList\nRobj\nVECSXP",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "data-types.html#other-types",
    "href": "data-types.html#other-types",
    "title": "R to Rust type mapping",
    "section": "Other types",
    "text": "Other types\n\nEnvironment (ENVSXP)\nExpressions (EXPRSXP)\nExternalPtr (EXTPTRSXP)\nFunction (CLOSSXP)\nLanguage (LANGSXP)\nRArray\nPairlist (LISTSXP)\nPromise (PROMSXP)\nS4 (S4SXP)",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "data-types.html#using-rust-library-types-vs-r-native-types",
    "href": "data-types.html#using-rust-library-types-vs-r-native-types",
    "title": "R to Rust type mapping",
    "section": "Using Rust library types vs R-native types",
    "text": "Using Rust library types vs R-native types",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "data-types.html#returning-rust-values-to-r",
    "href": "data-types.html#returning-rust-values-to-r",
    "title": "R to Rust type mapping",
    "section": "Returning Rust values to R",
    "text": "Returning Rust values to R",
    "crumbs": [
      "extendR: User guide",
      "R to Rust type mapping"
    ]
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "Conversion to and from R data",
    "section": "",
    "text": "One of the key goals with extendr, is to provide a framework that allows you to write Rust functions, that interact with R, without having to know the intricacies within R internals, or even R’s C-facilities. However, this is unavoidable if one wishes to understand why the extendr-api is the way it is.\nThus, for introducing extendr, we shall mention facts about R internals, but these are not necessary to keep in mind going forward.\nA fundamental data-type in R is the 32-bit integer, int in C, and i32 in Rust. Passing that type around is essential, and straight forward:\n#[extendr(use_try_from = true)]\nfn ultimate_answer() -&gt; i32 {\n    return 42_i32;\n}\nAnd now this function is available within your R-session, as the output is 42.\nAlso, another fundamental data-type in R is numeric / f64, which we can also pass back and forth uninhibitated, e.g.\n#[extendr(use_try_from = true)]\nfn return_tau() -&gt; f64 {\n    std::f64::consts::TAU\n}\nwhere \\(\\tau := 2\\pi =\\) \\(6.2831853\\).\nHowever, passing data from R to Rust must be done with a bit of care: In R, representing a true integer in literal form requires using L after the literal.\n#[extendr(use_try_from = true)]\nfn bit_left_shift_once(number: i32) -&gt; i32 {\n    number &lt;&lt; 1\n}\nThis function supposedly is a clever way to multiply by two, however passing bit_left_shift_once(21.1) results in\nError in bit_left_shift_once(21.1): Expected an integer or a float representing a whole number, got 21.1\nwhere bit_left_shift_once(21) is 42, as expected.\nR also has the concept of missing numbers, NA encoded within its data-model. However i32/f64 do not natively have a representation for NA e.g.\nbit_left_shift_once(NA_integer_)\n\nError in bit_left_shift_once(NA_integer_): Must not be NA.\n\nbit_left_shift_once(NA_real_)\n\nError in bit_left_shift_once(NA_real_): Must not be NA.\n\nbit_left_shift_once(NA)\n\nError in bit_left_shift_once(NA): Must not be NA.\nInstead, we have to rely on extendr’s scalar variants of R types, Rint / Rfloat to encompass the notion of NA in our functions:\n#[extendr(use_try_from = true)]\nfn double_me(value: Rint) -&gt; Rint {\n    if value.is_na() {\n        Rint::na()\n    } else {\n        (value.inner() &lt;&lt; 1).into()\n    }\n}\nwhich means, we can now handle missing values in the arguments\ndouble_me(NA_integer_)\n\n[1] NA\n\ndouble_me(NA_real_)\n\n[1] NA\n\ndouble_me(NA)\n\n[1] NA\nOne may notice here that NA_real_ was accepted even for an Rint. The reason for this, is when you specify a type without &/&mut, the value is coerced in a similar way, as R coerces values. In order to have strict type-checking during run-time, use & / &mut, as\n#[extendr(use_try_from = true)]\nfn wrong_input(value: &Rint) -&gt; Rint {\n    value.clone()\n}\nwrong_input(NA_integer_)\n\nError in wrong_input(NA_integer_): Must not be NA.\n\nwrong_input(NA_real_)\n\nError in wrong_input(NA_real_): expected 13, got 14\n\nwrong_input(21.0)\n\nError in wrong_input(21): expected 13, got 14\n\nwrong_input(21L)\n\n[1] 21\nHere, only the last literal is a true Rint.",
    "crumbs": [
      "extendR: User guide",
      "Conversion to and from R data"
    ]
  },
  {
    "objectID": "conversion.html#vectors",
    "href": "conversion.html#vectors",
    "title": "Conversion to and from R data",
    "section": "Vectors",
    "text": "Vectors\nMost data in R are vectors. Scalar values are in fact 1-sized vectors, and even lists are defined by a vector-type. A vector type in Rust is Vec. A Vec has a type-information, length, and capacity. This means, that if necessary, we may expand any given Vec-data to contain more values, and only when capacity is exceeded, will there be a reallocation.\nNaively, we may define a function like so\n\n#[extendr(use_try_from = true)]\nfn repeat_us(mut values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    assert_eq!(values.capacity(), values.len(), \"must have zero capacity left\");\n    values[0] = 100;\n    values.push(55);\n    values\n}\n\n\nx &lt;- c(1L, 2L, 33L)\nrepeat_us(x)\n\n[1] 100   2  33  55\n\n\nEven if the argument is mut Vec&lt;_&gt;, what happens is that the R vector gets converted to a Rust owned type, and it is that type that we can modify, and augment, with syncing to the original data.\nOf course, a slice e.g. &[i32] / &mut [i32] could be used instead, and this allows us to modify the original data, i.e.\n\n#[extendr(use_try_from = true)]\nfn zero_middle_element(values: &mut [i32]) {\n    let len = values.len();\n    let middle = len / 2;\n    values[middle] = 0;\n}\n\n\nx &lt;- c(100L, 200L, 300L)\nzero_middle_element(x)\nx\n\n[1] 100   0 300\n\n\nThis is great! If we wanted to insert an NA in the middle, we would have had to operate on &mut [Rint] instead.\nA slice is a representation of a sequence of elements that are part of a larger collection. Since they represent only part of a collection (vector, in this case), we cannot add new elements to this. To do so, we have to rely on extendr provided types, that provide a Vec-like API to R’s vector-types. These are the Integers, Logicals, Doubles, and Strings types.",
    "crumbs": [
      "extendR: User guide",
      "Conversion to and from R data"
    ]
  },
  {
    "objectID": "conversion.html#strings-are-special",
    "href": "conversion.html#strings-are-special",
    "title": "Conversion to and from R data",
    "section": "Strings are special",
    "text": "Strings are special",
    "crumbs": [
      "extendR: User guide",
      "Conversion to and from R data"
    ]
  }
]